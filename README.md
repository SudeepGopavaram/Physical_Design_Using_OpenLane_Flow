# Physical_Design_Using_OpenLane_Flow
This repository contains a detailed description of a RTL2GDSII flow using a opensource OpenLane flow, design used for this run is PicoRV32 which is a CPU core that implements the RISC-V Instruction Set.

![Static Badge](https://img.shields.io/badge/OS-linux-orange)
![Static Badge](https://img.shields.io/badge/EDA%20Tools-OpenLANE--Flow%2C_Yosys%2C_abc%2C_OpenROAD%2C_TritonRoute%2C_OpenSTA%2C_magic%2C_netgen%2C_GUNA-navy)
![Static Badge](https://img.shields.io/badge/languages-verilog%2C_bash%2C_TCL-crimson)
![GitHub last commit](https://img.shields.io/github/last-commit/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub language count](https://img.shields.io/github/languages/count/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub top language](https://img.shields.io/github/languages/top/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub repo size](https://img.shields.io/github/repo-size/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub code size in bytes](https://img.shields.io/github/languages/code-size/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub repo file count (file type)](https://img.shields.io/github/directory-file-count/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)

# Physical Design
It is a process of generating a layout from a given netlist, in which layout is represented in GDS or geometrical patterns which are written on mask for IC fabrication.

Following are inputs during this step and the final output is GDS:

**1. Netlist** - Netlist generated by the logic synthesis tool as an input to the physical design tool.

**2. Library** - A library which contains the cells instantiated in the above netlist is provided which helps in computing delay and other attributes for cell instances using this library.

**3. Constraints** - Design goals and constraints are provided to physical design tool through various design configuration variables which help to acheive the required result.

**4. Floorplan** - A floorplan captures the designer's intent about physical design. It defines the size and aspect ratio of a die. It contains location of hard macros, shape, location of various blocks, location of input/output (I/O) pads. It act as a constraint in placing various component and creating a wire layout.

**Major Tasks**

* Chip Planning
* Placement
* Clock Tree Synthesis
* Global Routing
* Detailed Routing
* ECO (Engineering Change Order)
* Write GDS

**What is PDK**

PDK stands for Process Design Kit. This is a kit which is basically provided by the foundry (fabrication vendors) to the customers for circuit design, circuit simulation, layout design, layout verification and parasitic extraction.

**For circuit design**, the PDK contains P-Cells (Parameterized Cells) of schematic. These P-Cells are the symbols of MOSFETs, BJTs, Diodes, Resistors, Capacitors, Inductors and Varactors etc. It is called P-Cells because the devices property can be changed by changing the parameters. For example, the MOSFET has few parameters called W (width), L (Length), F (Finger) and M (Multiplier). By changing the above parameters one can change the MOSFET property. Similarly, the other P-cells mentioned above have also few parameters to change their properties.

**For circuit simulation**, the PDK contains model files for the devices. This model file contains the model parameters of all the devices for a particular technology. During simulation of the circuits, the model file passed to the simulator along with the circuit netlist to complete the simulation. Few model parameters examples are VTO, GAMMA, LAMBDA, PHI, KP etc. Currently, BSIM-4 Model is used to simulate the circuit.

**For layout design**, the PDK contains P-Cells (Parameterized Cells) of layouts. These P-Cells are the layouts of MOSFETs, BJTs, Diodes, Resistors, Capacitors, Inductors and Varactors etc. It is called P-Cells because the devices dimension can be changed by changing the parameters. The advantages of the P-Cells Layout is, the same P-Cell layout can be re-used for creating other layout with different dimensions.

**For Layout Verification**, the PDK contains two rule files, one is DRC Rule File and the other one is LVS rule File. DRC rule file is used to do the design rule check (checking of spacing between layers, minimum and maximum widths, extension and enclosures etc.) in a layout. LVS rule file is used to check the correctness (nets, pins, device dimensions and device models should be same) between layout and schematic.

**For parasitic extraction**, the PDK contains a PEX rule file. This rule file contains the information of sheet resistance and unit capacitance of all the layers. During parasitic extraction phase based on the layers and their dimensions parasitic resistance and capacitance extracted.

Apart from the above, the PDK also contains standard cells, tech file, design rule manual (DRM) and some useful documents.
Note that P-Cells are different from standard cell. In P-Cells we can change the property and dimension of the device by changing the parameters but in standard cell we can’t change anything.

# OpenLane
It is an automated RTL2GDSII flow which make use of several other opensource tools throughout the run to generate the GDSII like, OpenROAD, Yosys, Magic, Netgen, CVC, SPEF-Extractor, KLayout and other custom script for optimized flow.

Physical design tool determines the location of all instances in a design which decides the clocking structure. It builds the topology of the metal and via layer for all nets in a design. Finally a layout represented in GDS format which contains all the information required for the fabricating a chip.


# OpenLane Architecture
![image](https://github.com/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow/assets/57873021/10499621-3e2f-4f80-b5a6-ffa6fa333f64)


RTL2GDSII flow consist of various steps involved which help in converting Register Transfer Level(RTL) to a fabrication ready GDSII(Graphic Design System) format it is a industry standard for data exchange of IC layout.

* RTL Synthesis
* Static Timing Analysis(STA)
* Design for Testability(DFT)
* Floorplanning
* Placement
* Clock Tree Synthesis(CTS)
* Routing
* GDSII Streaming

This repository shows the detailed execution of all the above mentioned steps to complete the flow.

### OpenLane Directory Hierarchy:

``` 
├── OpenLane              -> directory where the tool can be invoked (make mount first)
│   ├── designs           -> All designs are present in this folder
│   │   │   ├── picorv32a -> Design used as case study for this flow this contains all the required files to succesfully run the flow like (.v, .sdc, congif files etc)
│   |   |   ├── ...
|   |   ├── ...
├── pdks                 -> contains pdk related files 
│   ├── skywater-pdk     -> all Skywater 130nm PDKs
│   ├── open-pdks        -> contains scripts that makes the commerical PDK (which is normally just compatible to commercial tools) to also be compatible with the open-source EDA tool
│   ├── sky130A          -> pdk variant made especially compatible for open-source tools
│   │   │  ├── libs.ref  -> files specific to node process (timing lib, cell lef, tech lef) for example is `sky130_fd_sc_hd` (Sky130nm Foundry Standard Cell High Density)  
│   │   │  ├── libs.tech -> files specific related to the tool (klayout,netgen,magic...) 
```

**Skywater Technology**
   
![image](https://github.com/SudeepGopavaram/Design_and_analysis_of_nmos_and_pmos_using_sky130pdk/assets/57873021/f8f19c5c-1ded-40c1-a87b-82dc2e572bab)

The [SkyWater](https://www.skywatertechnology.com/technology-and-design-enablement/) Technology Foundry 130nm Process Design Kit (PDK) is a comprehensive collection of files, libraries, and documentation that enables the design and fabrication of integrated circuits (ICs) using the SkyWater 130nm process technology.

The SkyWater130 PDK is typically utilized in conjunction with electronic design automation (EDA) tools, enabling designers to create and verify their IC designs 
within a familiar design environment. The PDK provides the necessary information for layout design, including design rules, layer information, and guidelines for 
ensuring compatibility with the SkyWater 130nm process technology.

Overall, the SkyWater130 PDK is an essential resource for IC designers seeking to leverage the capabilities of the SkyWater 130nm process technology. Its 
comprehensive set of files, libraries, and guidelines streamline the design process and facilitate the creation of high-quality integrated circuits.

> *You can refer to skywater130 manual [here](https://skywater-pdk.readthedocs.io/en/main/)*

 **Yosys -- Yosys Open SYnthesis Suite**
 
![image](https://github.com/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow/assets/57873021/61878d69-c9fe-4f25-86e1-989ac45dea4d)
This tool is used to perform any synthesis job it is a framework for verilog RTL synthesis and provides a basic set of synthesis algorithms for various application domains

> *You can refer to Magic manual [here](https://yosyshq.readthedocs.io/projects/yosys/en/latest/)*

**1.1 Ngspice**
   
  ![image](https://github.com/SudeepGopavaram/Design_and_analysis_of_nmos_and_pmos_using_sky130pdk/assets/57873021/9073cdd0-8e57-4177-9557-cc476fa6e9c2)

  [Ngspice](https://ngspice.sourceforge.io/) is an open-source mixed-level/mixed-signal electronic circuit simulator widely used for circuit design, analysis, and verification. It allows users to 
  model and simulate the behavior of electronic circuits using a variety of circuit elements, including resistors, capacitors, inductors, transistors, and more.

  Ngspice provides a command-line interface for interaction and scripting, making it flexible and suitable for both interactive usage and automated workflows. It 
  supports a wide range of circuit netlist formats, including the popular SPICE format, allowing seamless integration with existing design flows and tools.

   Its versatility and accessibility make it a valuable asset in the field of electronic design automation.

   > *You can refer to Ngspice manual [here](https://ngspice.sourceforge.io/docs.html)*

  <section id = "magic" nane = "magic" class = "anchor" >

 ## **1.2 Magic**
   ![image](https://github.com/SudeepGopavaram/Design_and_analysis_of_nmos_and_pmos_using_sky130pdk/assets/57873021/57ec58d6-9023-4d6a-ae0e-eb2db101f1db)

   [Magic](http://opencircuitdesign.com/magic/) is an open-source layout tool widely used in the field of digital integrated circuit design. It provides a powerful platform for creating and editing 
   layouts of integrated circuits at various levels of abstraction, ranging from individual transistors to complete chip designs.
   
   Magic offers a range of features to enhance productivity and design efficiency. It includes a comprehensive set of drawing tools and alignment aids to facilitate 
   precise and accurate layout creation. It supports design rule checking (DRC) and layout versus schematic (LVS) verification, helping to identify and resolve 
   potential design errors and mismatches.

   Its feature-rich nature, extensibility, and community support make it an invaluable asset in the realm of digital integrated circuit design.

   > *You can refer to Magic manual [here](http://opencircuitdesign.com/magic/magic_docs.html)*

</section>


# Chip Planning Terminology
Physical design process starts with the *Chip Planning*. Physical Design implementation is strongly depends on the size of design and for large system we decompose them into the sub-systems or blocks which is also known as *partitioning*.

After partitioning we determine the location of each block and macros. we carry out pin assignment, define the location of input and output pads, allocatin adequate space for creating rows of standard cells which is known as floorplaning

Power planning is also done during the chip planning phase.

**DIE-SIZE** - For layout to be created we need to first define the die size and its aspect ratio. Ideally die size should be as small as possible which will allow us to fabricate more chips for a given wafer area, also reducing area reduces the cost of the chip also enables us to achieve a higher yield for smaller die.

Die-Size should be able to accomodate the following entities:

**1. Blocks** - A separate space need to be allocated on the layout for larger instances or blocks or macros. These blocks can obtained after partitioning or it can be functional blocks like processors, memories or analog blocks.

**2. Standard Cell** - Standard cell are placed on a die therefore a dedicated space is allocated for them. Area required for the standard cells can be estimated using the given netlist and the corresponding technology library.

**3. Pads** - I/O pads are required for the signals to enter or leave from a chip. Also power must be delivered to the chip using power and ground pads.

**4. Interconnects** - There must be provision of interconnects in the layout but during floorplan stage, the layout of the interconnect is not yet decided so it is challenging to estimate the area we must allocate for the interconnects on the die.

**5. Core Utilization or Core Area** - It is the die area excluding the area of the I/O pads and the power pads this is know as *core utilization*.

**6. Package** - It is a protective case that surrounds the circuit material to protect it from physical damage or corrosion and allow mounting of electrical contacts connecting it ti the PCB. Below shown snippet shows IC with 48 pins and Quad Flat No-Leads(QFN) package.


![image](https://github.com/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow/assets/57873021/95842423-0621-478f-b4e4-85212be5c3e3)


# Getting Started With the Flow

## **1. Running design synthesis using OpenLane flow and generate required output**

**Logic Synthesis**

It converts an RTL model to a functionally equivalent netlist, it requires following inputs

**1. Design** - We provide RTL model which is typically represented in verilog to a logic synthesis tool. 

**2. Technology library** - Tool creates a netlist by choosing *standard cells* from the given *technology library*. A library is modeled in Liberty format which defines attributes like delay, power and area of each standard cell.

**3. Constraints** - It decides the design goals related to expected timing behaviour, such as maximum operable frequency. Constraints are typically specified in Synopsys Design Constraint (SDC) format.

***Design Used - picorv32a***

PicoRV32 is a CPU core that implements the RISC-V RV32IMC Instruction Set. It can be configured as RV32I, RV32IC, RV32IM, or RV32IMC core
PicoRV32 is free and open hardware licensed under the ISC license. All features and data-sheet related to picoRV32 core can be obtained [here.](https://github.com/YosysHQ/picorv32)

Adding our new design 

```
make mount
./flow.tcl -design picorv32a -init_design_config -add_to_designs -config_file config.tcl
it will create the respective directory and files

picorv32a
├── config.tcl
└── src
1 directory, 1 file
```

```bash
# Change directory to openlane flow directory
cd Desktop/work/tools/openlane_working_dir/openlane

# alias docker='docker run -it -v $(pwd):/openLANE_flow -v $PDK_ROOT:$PDK_ROOT -e PDK_ROOT=$PDK_ROOT -u $(id -u $USER):$(id -g $USER) efabless/openlane:v0.21'
# Since we have aliased the long command to 'docker' we can invoke the OpenLANE flow docker sub-system by just running this command
docker
```

```tcl
# Now that we have entered the OpenLANE flow contained docker sub-system we can invoke the OpenLANE flow in the Interactive mode using the following command
./flow.tcl -interactive 

# Now that OpenLANE flow is open we have to input the required packages for proper functionality of the OpenLANE flow which retrives all dependencies for running v0.9
package require openlane 0.9

# Now the OpenLANE flow is ready to run any design and initially we have to prep the design creating some necessary files and directories for running a specific design which in our case is 'picorv32a'
prep -design picorv32a

# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis

# Exit from OpenLANE flow
exit

# Exit from OpenLANE flow docker sub-system
exit
```

![Screenshot (360)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/3a7c600a-56bf-4f2f-befa-15a41551d9b9)

![Screenshot (361)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/e35a58e3-c35c-4b21-a3d6-a999092a20db)

**2. Calculating Flop Ratio**

```math
Flop\ Ratio = \frac{Number\ of\ D\ Flip\ Flops}{Total\ Number\ of\ Cells}
```

```math
Percentage\ of\ DFF's = Flop\ Ratio * 100
```

![Screenshot (363)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/4c2b742b-e003-493d-a999-de56758b5aa5)

![Screenshot (362)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/21a4219b-fec5-4fda-8014-7788ba2d420a)

```math
Flop\ Ratio = \frac{1613}{14876} = 0.1084
```

```math
Percentage\ of\ DFF's = 0.1084 * 100 = 10.84%
```

## **2. Florplan and Placement Stage**

**FLOORPLAN STAGE**

There are three styles of floorplan: *fully abutted*, *channel-based*, and *mixed* floorplan

**1. Fully Abutted floorplan** - It has no extra routing resources at the top level so entire top level wiring is done over the macros. We connect the blocks using abutment and pin alignment.

**2. Channel-based floorplan** - In this we ensure to keep gaps between blocks to allow top-level routing, these gaps are reffered to as channels. There is a chance of congestion issues in the channel since all top-level routing goes through it. Some routes through the channel can be longer than a direct path through another block.

**3. Mixed Floorplan** - It is a combination of both abutted and channel-based floorplan style. We abut blocks and create connections by pin alignment wherever possible, also create channels where top-level cells are needed between blocks or cells like clock routing buffers.

**Standard Cell Rows** - after placing object or macros in layout we can allocate the remaining area for standard cell rows, keeping the height of the rows equal to standard cell's height. Standard cell rows are created using abutment which allows adjacent rows to share the supply power rails (Vdd) and ground rails (GND).

**Pin Assignment** - Block location is fixed during the floorplan following by the fixing of position of pins of the blocks along the block boundaries this is known as *pin assignment*. Information required for pin placement is the partitioned netlist, the floorplan, the number of pins on each block and their relative ordering.

**Power Planning** - Chip draws external power through power pads delivering power to each active element of circuit. We make power ring across the periphery of a die and connect appropriate apdn to the power rings. Metal lines run horizontally and vertically in alternate metal layer and vias are added at their intersections this topology is called *mesh grid opology*. In this the horizontal metal lines are called *power rails* and vertical metal lines as *power straps*.

![2stage](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/c2e97cb9-0eb2-4191-a050-e9efd4062c4f)

**PLACEMENT STAGE**

One of the critical task to determine the locations of each entity in a design. We determine the position of larger entities such as memories, analog blocks, macros and input/output (I/O) pads during the floorplan stage. However location of numerous standard cell in decided in placement stage, primary aim for this stage is to make design routable. Placement methodology targets improving the slack of the timimg paths known as timing-driven placement.
Placement task is divided into multiple tasks like *global placement*, *legalization* followed by the *detailed palcement*

We try to find approximate cell locations by spreading the cells over the layout reducing the cell density cell location is decided by their connectivity and we ignore the attributes of the cell such as its size and pin location this is known as *global placement*. After this cell can overlap and occupy illegal positions which are fixed during the legalization and detailed placement stage.

```
configuration/
├── checkers.tcl
├── cts.tcl
├── extraction.tcl
├── floorplan.tcl
├── general.tcl
├── load_order.txt
├── placement.tcl
├── routing.tcl
└── synthesis.tcl

0 directories, 9 files
```

```
# Now that we have entered the OpenLANE flow contained docker sub-system we can invoke the OpenLANE flow in the Interactive mode using the following command
./flow.tcl -interactive

# Now that OpenLANE flow is open we have to input the required packages for proper functionality of the OpenLANE flow
package require openlane 0.9

# Now the OpenLANE flow is ready to run any design and initially we have to prep the design creating some necessary files and directories for running a specific design which in our case is 'picorv32a'
prep -design picorv32a

# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis

# Now we can run floorplan
run_floorplan
```

![floorplan run](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/d191a6c6-a4d3-4a40-88df-68201a23a1f5)


![floorplan run](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/b16fb76e-6095-477d-b196-ba10181e4072)


![floorplan run](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/d8062761-60c0-40d5-af50-2a22e7dff6ff)


![floorplan log](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/409961df-15b4-4672-839b-391bfe61f806)

after succesgul flooprplan run there will be a log generated from which can extract following content

```math
1000\ Unit\ Distance = 1\ Micron
```

```math
Die\ width\ in\ unit\ distance = 6600685 - 0 = 660685
```

```math
Die\ height\ in\ unit\ distance = 671405 - 0 = 671405
```

```math
Distance\ in\ microns = \frac{value\ in\ Unit\ Distance}{1000}
```

```math
Die\ width\ in\ microns = \frac{660685}{1000} = 660.685\ microns
```

```math
Die\ height\ in\ microns = \frac{671405}{1000} = 671.405\ microns
```

```math
Area\ of\ Die = Die\ height\ * Die\ widht
```

```math
Area\ of\ Die = 660.685 * 671.405 = 443587.212425\ square\ microns
```
```bash
# To invoke magic tool to view generated def file make sure in respective def generated dirctory
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.floorplan.def &
```

![floorplan def zoomed](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/685dbb65-afe2-4017-b897-94eecd9d11e5)

![floorplan def](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/058e242f-7196-46ba-a7b6-c4d73327d640)

after succesfully running floorplan stage now we will run the placement stage

```bash
# To run placement stage
run_placement
```

```bash
# Loading def file again after placement run make sure you are in respective def generated directory
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.placement.def &
```

![placement def normal](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/6078adf0-edf7-4c84-bb40-139a296ceb72)

![placement def zoomed](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/fef07c24-7ca1-46d4-9d1f-080611fc40f3)

From the above results we can generated a floorplan with eqiudistant placement of ports, equidistant placement of Decap and Tap cells. And after placement standard cells are legally placed succesfully.


day -3 Characterization of standard cell inverter

**SPICE Netlist** - It is a simple circuit description language which is composed of components with terminals attached to particular nodes. These group of components attached to nodes are called netlist.

It is organised into different parts. When a command or component description is continued on multiple linea, a "+" begins each following line so that spice knows it belongs to whatever is on the previous line.
Any line to be ignored starts with a "*".

In short a spice netlist consist of following things:

* component connectivity

* component values

* identify nodes

* naming of nodes

**Spice Device Definition**
**1. Capacitor Component** - 

Cxx N+ N- VALUE [IC=INCOND]

The parameters are:

N+        = the positive termianl

N-        = the negative terminal

VALUE     = capacitance in farads

IC=INCOND = starting voltage in simulation

**2. MOSFET Component**

MXX ND NG NS NB MNAME L=VAL W=VAL [AD=VAL] [AS=VAL] [PD=VAL] [PS=VAL] [NRD=VAL] [NRS=VAL] [OFF] 
+ [IC=VDS, VGS, VBS] [TEMP=T]

The parameters are:

ND                 = the name of the drain terminal

NG                 = the name of the gate terminal

NS                 = the name of the source terminal

NB                 = the name of the bulk (backgate) terminal

MNAME              = name of the model used

L=VAL              = length of the gate in meters

W=VAL              = width of the gate in meters

AD=VAL             = area of the drain contact in sqare meters

AS=VAL             = area of the source contact in sqare meters

PD=VAL             = perimeter of the drain contact in meters

PS=VAL             = perimeter of the source contact in meters

NRD=VAL            = equivalent squares that make up the drain to determine the drain resistance

NRS=VAL            = equivalent squares that make up the source to determine the source resistance

OFF                = an optional starting condition for DC analysis

IC=VDS, VGS, VBS>  = starting voltage in a simulation

TEMP=T             = temperature of the transistor in Kelvin

**3. Voltage Source Component**

VXX N+ N- <<DC> DC/TRAN VALUE> <AC <ACMAG <ACPHASE>>> <DISTOF1 <F1MAG <F1PHASE>>> <DISTOF2 <F2MAG
+ <F2PHASE>>>
  
The parameters are:

N+                          = the name of the positive terminal

N-                          = the name of the negative terminal

<<DC> DC/TRAN VALUE>        = the DC offset of the voltage source

<<AC> ACMAG <ACPHASE>>>     = the AC magnitude and phase applied in an AC analysis

<DISTOF1 <F1MAG <F1PHASE>>> = a distortion factor at frequency F1

<DISTOF2 <F2MAG <F2PHASE>>> = a distortion factor at frequency F2

The DC value can be changed in time by using functions such as pulse(), sin(), exp(), and pwl().
The distortion factors only operate with a .disto command.

**Current and Voltage Source DC Functions**

**1. Pulse Function**

PULSE (V1 V2 <TD> <TR> <TF> <PW> <PER>)

The parameters are:

V1  = the initial value (volts or amps)

V2  = the pulsed value (volts or amps)

TD  = the seconds before the first pulsed value

TR  = the seconds it takes the pulse to rise from V1 to V2

TF  = the seconds it takes the pulse to fall from V2 to V1

PW  = the number of seconds the signal stays at V2

PER = the time between each rising edge of the pulse after the first initial pulse

oen of the feature of openlane is we can make changes on the fly for the specific stage and rerun that stage agin to get the changes visible itselff.
io place is opensource tool used to place the ios round the die.

# CMOS inverter VTC analysis

In a CMOS circuit, PMOS transistors are used to implement logic functions when the input is at a low voltage level (logic 0), while NMOS transistors are used for logic functions when the input is at a high voltage level (logic 1). This arrangement allows for efficient power consumption since current flows only when the transistors switch states.

The basic building block of a CMOS circuit is the CMOS inverter, which consists of a PMOS transistor and an NMOS transistor connected in series. The input is applied to both transistors' gates, and the output is taken from their common connection, known as the output node.

When the input is at logic 0, the PMOS transistor turns on, creating a low resistance path between the supply voltage (VDD) and the output node, pulling the output to logic 1. At the same time, the NMOS transistor turns off, ensuring no current flows from the output node to ground. That is why PMOS is used in pull up network.

On the other hand, when the input is at logic 1, the PMOS transistor turns off, while the NMOS transistor turns on. This allows the output node to be connected to ground, pulling the output to logic 0. The NMOS transistor acts as a low resistance path to discharge any charge on the output node. That is why NMOS is used in pull down network.

CMOS circuits can be cascaded to implement more complex digital functions, such as logic gates (AND, OR, XOR, etc.), flip-flops, and arithmetic units. CMOS technology offers advantages such as low power consumption and high noise immunity, making it the dominant technology for digital circuit design. 

![spice .cir](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/bd6c09f4-c1e4-4df9-a9b4-f2cf5e53b4fd)

 
```spice
** sch_path: /home/sudeep/.xschem/simulations/inverter_std.sch
**.subckt inverter_std vin vout

*.ipin vin
*.opin vout
XM1 vout vin GND GND sky130_fd_pr__nfet_01v8 L=0.25 W=1 nf=1 ad='int((nf+1)/2) * W/nf * 0.29' as='int((nf+2)/2) * W/nf * 0.29' pd='2*int((nf+1)/2) * (W/nf + 0.29)'
+ ps='2*int((nf+2)/2) * (W/nf + 0.29)' nrd='0.29 / W' nrs='0.29 / W' sa=0 sb=0 sd=0 mult=1 m=1
XM2 vout vin VDD VDD sky130_fd_pr__pfet_01v8 L=0.25 W=1 nf=1 ad='int((nf+1)/2) * W/nf * 0.29' as='int((nf+2)/2) * W/nf * 0.29' pd='2*int((nf+1)/2) * (W/nf + 0.29)'
+ ps='2*int((nf+2)/2) * (W/nf + 0.29)' nrd='0.29 / W' nrs='0.29 / W' sa=0 sb=0 sd=0 mult=1 m=1
cload vout GND 10f
VDD VDD GND 1.8
vin vin GND 1.8

**** begin user architecture code
** opencircuitdesign pdks install
.lib /usr/local/share/pdk/sky130A/libs.tech/combined/sky130.lib.spice tt

.dc vin 0 1.8 0.01
.save all

**** end user architecture code
**.ends
.GLOBAL VDD
.GLOBAL GND
.end
```

```
# invoke the ngspice and source the repective netlist
source <netlist>

# Will run the simulatio
run

# To view the available plots
setplot - will show different plots available

# To view different voltages and current to plot
display - will show different voltaages and current to plot

# To plot the waveforms
plot <variable> .....
```

SPICE waveform : Wn=Wp=1u, Ln=Lp=0.25u
(Wn/Ln=Wp/Lp=4)
![dc analysis)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/a60f14c4-a940-49d9-8b56-be5082d1be5b)

![vtc plot](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/f9346f2e-fa5b-40fa-9841-9b6b0631b793)


SPICE waveform : Wn=1u, Wp=2.5u, Ln=Lp=0.25u
(Wn/Ln=4, Wp/Lp=10)

![Screenshot (378)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/1ca809c8-a1e4-43ca-9228-5a4199ecca19)


speciality of cmos
cmos is a robust device
switching threshold (static behaviour)


```spice
** sch_path: /home/sudeep/.xschem/simulations/inverter_std.sch
**.subckt inverter_std vin vout
*.ipin vin
*.opin vout
XM1 vout vin GND GND sky130_fd_pr__nfet_01v8 L=0.25 W=2.5 nf=1 ad='int((nf+1)/2) * W/nf * 0.29' as='int((nf+2)/2) * W/nf * 0.29' pd='2*int((nf+1)/2) * (W/nf + 0.29)'
+ ps='2*int((nf+2)/2) * (W/nf + 0.29)' nrd='0.29 / W' nrs='0.29 / W' sa=0 sb=0 sd=0 mult=1 m=1
XM2 vout vin VDD VDD sky130_fd_pr__pfet_01v8 L=0.25 W=1 nf=1 ad='int((nf+1)/2) * W/nf * 0.29' as='int((nf+2)/2) * W/nf * 0.29' pd='2*int((nf+1)/2) * (W/nf + 0.29)'
+ ps='2*int((nf+2)/2) * (W/nf + 0.29)' nrd='0.29 / W' nrs='0.29 / W' sa=0 sb=0 sd=0 mult=1 m=1
cload vout GND 10f
VDD VDD GND 1.8
vin vin GND pulse 0 1.8 0 10p 10p 1n 2n

**** begin user architecture code
** opencircuitdesign pdks install
.lib /usr/local/share/pdk/sky130A/libs.tech/combined/sky130.lib.spice tt

.tran 10p 4n
.save all

**** end user architecture code
**.ends
.GLOBAL VDD
.GLOBAL GND
.end
```

Waveform for the pulse 0 2.5 0 10p 10p 1n 2n
![pulse waveform](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/6563146e-e468-42b0-a171-7ea7f14999a0)

![tran](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/2db865f9-fd22-4fdd-bc7a-b60fa6e462ac)

![waveform](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/18e32085-1ff9-450b-ac6e-8c7a2661bc0a)




Wp/Lp          x.Wn/Ln
"               1."
"               2."
"               3."
"               4."
"               5."



rise delay     fall delay
values            value

sky130 stack diagram
about magic tool
standard cell inverter layout

extraction
pwd
extract all
ext2spice ctrhesh 0 rthresh 0 // to extract parasitics
ext2spice

netlist file

rise time fall time definition


**Finding and fixing the problem in the DRC section of old magic tech file for skywater technology 
wget http://opencircuitdesign.com/open_pdks/archive/drc_tests.tgz
tar xzf "

implant layer are automatically generated in layout view they are not visible t view them  is to use cifc command to highlight those area

.magicrc startup file for magic
magic -d XR


![poly.mag](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/da00447b-bd79-4ce3-8ca1-a45063e8f9ff)

![corrected poly.9](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/b628ae8c-4a39-4554-bb71-12bb8e21d22c)



![difftap](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/e2b1f563-0e86-43ac-be0b-31599d36f849)



![corrected difftap.2](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/b058b59c-0c14-4f5c-a0a4-9fa3ce7b1c5b)

[here](https://skywater-pdk.readthedocs.io/en/main/rules/periphery.html#x)

met3.mag
drc why
paint m3con
cif see VIA2 
feed clear

1st exercise
load poly.mag
go to tech file in drc section
find the specific rule in tech file
*infront of layers means that specific layer and all the contacts containing rtthat layer
aliiases
tech load *file*
drc check

day -4 

**Some guidelines to follow while making standard cells**

* The input and output ports of the standard cell should lie on the intersection of the vertical and horizontal tracks.
* Width of the standard cell should be odd multiples of the horizontal track pitch.
* Height of the standard cell should be even multiples of the vertical track pitch.

  ```
  # clone the following repository for standard cell layout using
  git clone https://github.com/nickson-jose/vsdstdcelldesign.git

  # open the custom inverter layout using
  magic -T sky130A.tech sky130_inv.mag
  ```

  ![Screenshot (384)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/da9f6a0e-e336-424e-add4-4aea2b00c54d)


what are tracks in layout?

![track file](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/0cc16b8e-a9da-4b1b-9da2-020564f881e6)

above file determines the following things

layer\ name\ x\ Horizontal offset\ Horizontal track pitch
layer\ name\ y\ Vertical offset\ Vertical track pitch


It determines the pitch and offset value for every metal layer in the proceess in both horizontal and vertical direction


![Screenshot (386)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/5e8559c2-4ee3-4222-b5c8-c476fe7d74dd)


generating lef using the tkcon window

```
# generating lef
lef write
```

![generated lef](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/6630447f-38bb-4fca-a446-79c7865c7a47)

now we will try to use this custom standard cell in out picorv32a design so for that we will be copying all the library files and lef file and adding the required changes in the config.tcl file.

```
set ::env(LIB_SYNTH) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__typical.lib"
set ::env(LIB_FASTEST) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__fast.lib"
set ::env(LIB_SLOWEST) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__slow.lib"
set ::env(LIB_TYPICAL) "$::env(OPENLANE_ROOT)/designs/picorv32a/src/sky130_fd_sc_hd__typical.lib"

set ::env(EXTRA_LEFS) [glob $::env(OPENLANE_ROOT)/designs/$::env(DESIGN_NAME)/src/*.lef]
```
include the below commands to include the additional lef into the flow

```
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs
```

![Screenshot (390)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/a557c341-7ffe-4419-a1d4-875c3e65d555)

after the run we can see that there is a huge slack violation at the synthesis stage 
![Screenshot (388)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/fdcff63f-73b6-465f-9574-c41525a6f0b7)

to meet the slcak requirements we will cahnge the parameters to improve timing and run synthesis

```
# Now once again we have to prep design so as to update variables
prep -design picorv32a -tag 24-03_10-03 -overwrite

# Addiitional commands to include newly added lef to openlane flow merged.lef
set lefs [glob $::env(DESIGN_DIR)/src/*.lef]
add_lefs -src $lefs

# Command to display current value of variable SYNTH_STRATEGY
echo $::env(SYNTH_STRATEGY)

# Command to set new value for SYNTH_STRATEGY
set ::env(SYNTH_STRATEGY) "DELAY 3"

# Command to display current value of variable SYNTH_BUFFERING to check whether it's enabled
echo $::env(SYNTH_BUFFERING)

# Command to display current value of variable SYNTH_SIZING
echo $::env(SYNTH_SIZING)

# Command to set new value for SYNTH_SIZING
set ::env(SYNTH_SIZING) 1

# Command to display current value of variable SYNTH_DRIVING_CELL to check whether it's the proper cell or not
echo $::env(SYNTH_DRIVING_CELL)

# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis
```

manufacturing process

# Glossary

**Library Exchange Format (LEF)** : It is given by the foundry which contains the abstract information about the designIt includes unit definition, maufacturing grid, implant layer, Via, macro, macro pin statement etc. It has various flavours like standard cell lef contains physical information about various cells, Tech lef contains physical information about metal layers like spacing, pitch etc.

**Design Exchange Format (DEF)** : This file consist of information regarding placement of macros, I/O pins, standard cells and other physical entities. Initial DEF to the flow is given by the synthesis stage. It get updated at every stage of the physical design flow. Physical deign data contains routing geometry, placement location and orientation. It is an input to various stages in physical design.
In short it conatains dies are, tracks, components(macros), I/O pins, nets, Halo, vias, metal layers.

**Liberty Timimg File (LIB)** : It is a timimg model ontaining the cell delays, setup and hold time requirements. Composite current source (CCS) and non linear delay model (NLDM) are used to generate .lib files.
Designs are needed to be tested for certain PVT corners and for every PVT corner timing of a cell is different and hence .lib file is for every PVT corner.
