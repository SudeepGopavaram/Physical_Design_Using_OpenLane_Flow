# Physical_Design_Using_OpenLane_Flow
This repository contains a detailed description of a RTL2GDSII flow using a opensource OpenLane flow, design used for this run is PicoRV32 which is a CPU core that implements the RISC-V Instruction Set.

![Static Badge](https://img.shields.io/badge/OS-linux-orange)
![Static Badge](https://img.shields.io/badge/EDA%20Tools-OpenLANE--Flow%2C_Yosys%2C_abc%2C_OpenROAD%2C_TritonRoute%2C_OpenSTA%2C_magic%2C_netgen%2C_GUNA-navy)
![Static Badge](https://img.shields.io/badge/languages-verilog%2C_bash%2C_TCL-crimson)
![GitHub last commit](https://img.shields.io/github/last-commit/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub language count](https://img.shields.io/github/languages/count/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub top language](https://img.shields.io/github/languages/top/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub repo size](https://img.shields.io/github/repo-size/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub code size in bytes](https://img.shields.io/github/languages/code-size/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub repo file count (file type)](https://img.shields.io/github/directory-file-count/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)

# Physical Design
It is a process of generating a layout from a given netlist, in which layout is represented in GDS or geometrical patterns which are written on mask for IC fabrication.

Following are inputs during this step and the final output is GDS:

**1. Netlist** - Netlist generated by the logic synthesis tool as an input to the physical design tool.

**2. Library** - A library which contains the cells instantiated in the above netlist is provided which helps in computing delay and other attributes for cell instances using this library.

**3. Constraints** - Design goals and constraints are provided to physical design tool through various design configuration variables which help to acheive the required result.

**4. Floorplan** - A floorplan captures the designer's intent about physical design. It defines the size and aspect ratio of a die. It contains location of hard macros, shape, location of various blocks, location of input/output (I/O) pads. It act as a constraint in placing various component and creating a wire layout.

**Major Tasks**

* Chip Planning
* Placement
* Clock Tree Synthesis
* Global Routing
* Detailed Routing
* ECO (Engineering Change Order)
* Write GDS

What is pdk?

# OpenLane
It is an automated RTL2GDSII flow which make use of several other opensource tools throughout the run to generate the GDSII like, OpenROAD, Yosys, Magic, Netgen, CVC, SPEF-Extractor, KLayout and other custom script for optimized flow.

Physical design tool determines the location of all instances in a design which decides the clocking structure. It builds the topology of the metal and via layer for all nets in a design. Finally a layout represented in GDS format which contains all the information required for the fabricating a chip.


# OpenLane Architecture
![image](https://github.com/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow/assets/57873021/10499621-3e2f-4f80-b5a6-ffa6fa333f64)


RTL2GDSII flow consist of various steps involved which help in converting Register Transfer Level(RTL) to a fabrication ready GDSII(Graphic Design System) format it is a industry standard for data exchange of IC layout.

* RTL Synthesis
* Static Timing Analysis(STA)
* Design for Testability(DFT)
* Floorplanning
* Placement
* Clock Tree Synthesis(CTS)
* Routing
* GDSII Streaming

This repository shows the detailed execution of all the above mentioned steps to complete the flow.

### OpenLane Directory Hierarchy:

``` 
├── OpenLane              -> directory where the tool can be invoked (make mount first)
│   ├── designs           -> All designs are present in this folder
│   │   │   ├── picorv32a -> Design used as case study for this flow this contains all the required files to succesfully run the flow like (.v, .sdc, congif files etc)
│   |   |   ├── ...
|   |   ├── ...
├── pdks                 -> contains pdk related files 
│   ├── skywater-pdk     -> all Skywater 130nm PDKs
│   ├── open-pdks        -> contains scripts that makes the commerical PDK (which is normally just compatible to commercial tools) to also be compatible with the open-source EDA tool
│   ├── sky130A          -> pdk variant made especially compatible for open-source tools
│   │   │  ├── libs.ref  -> files specific to node process (timing lib, cell lef, tech lef) for example is `sky130_fd_sc_hd` (Sky130nm Foundry Standard Cell High Density)  
│   │   │  ├── libs.tech -> files specific related to the tool (klayout,netgen,magic...) 
```

**Skywater Technology**
   
![image](https://github.com/SudeepGopavaram/Design_and_analysis_of_nmos_and_pmos_using_sky130pdk/assets/57873021/f8f19c5c-1ded-40c1-a87b-82dc2e572bab)

The [SkyWater](https://www.skywatertechnology.com/technology-and-design-enablement/) Technology Foundry 130nm Process Design Kit (PDK) is a comprehensive collection of files, libraries, and documentation that enables the design and fabrication of integrated circuits (ICs) using the SkyWater 130nm process technology.

The SkyWater130 PDK is typically utilized in conjunction with electronic design automation (EDA) tools, enabling designers to create and verify their IC designs 
within a familiar design environment. The PDK provides the necessary information for layout design, including design rules, layer information, and guidelines for 
ensuring compatibility with the SkyWater 130nm process technology.

Overall, the SkyWater130 PDK is an essential resource for IC designers seeking to leverage the capabilities of the SkyWater 130nm process technology. Its 
comprehensive set of files, libraries, and guidelines streamline the design process and facilitate the creation of high-quality integrated circuits.

> *You can refer to skywater130 manual [here](https://skywater-pdk.readthedocs.io/en/main/)*

 **Yosys -- Yosys Open SYnthesis Suite**
 
![image](https://github.com/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow/assets/57873021/61878d69-c9fe-4f25-86e1-989ac45dea4d)
This tool is used to perform any synthesis job it is a framework for verilog RTL synthesis and provides a basic set of synthesis algorithms for various application domains

> *You can refer to Magic manual [here](https://yosyshq.readthedocs.io/projects/yosys/en/latest/)*

**1.1 Ngspice**
   
  ![image](https://github.com/SudeepGopavaram/Design_and_analysis_of_nmos_and_pmos_using_sky130pdk/assets/57873021/9073cdd0-8e57-4177-9557-cc476fa6e9c2)

  [Ngspice](https://ngspice.sourceforge.io/) is an open-source mixed-level/mixed-signal electronic circuit simulator widely used for circuit design, analysis, and verification. It allows users to 
  model and simulate the behavior of electronic circuits using a variety of circuit elements, including resistors, capacitors, inductors, transistors, and more.

  Ngspice provides a command-line interface for interaction and scripting, making it flexible and suitable for both interactive usage and automated workflows. It 
  supports a wide range of circuit netlist formats, including the popular SPICE format, allowing seamless integration with existing design flows and tools.

   Its versatility and accessibility make it a valuable asset in the field of electronic design automation.

   > *You can refer to Ngspice manual [here](https://ngspice.sourceforge.io/docs.html)*

  <section id = "magic" nane = "magic" class = "anchor" >

 ## **1.2 Magic**
   ![image](https://github.com/SudeepGopavaram/Design_and_analysis_of_nmos_and_pmos_using_sky130pdk/assets/57873021/57ec58d6-9023-4d6a-ae0e-eb2db101f1db)

   [Magic](http://opencircuitdesign.com/magic/) is an open-source layout tool widely used in the field of digital integrated circuit design. It provides a powerful platform for creating and editing 
   layouts of integrated circuits at various levels of abstraction, ranging from individual transistors to complete chip designs.
   
   Magic offers a range of features to enhance productivity and design efficiency. It includes a comprehensive set of drawing tools and alignment aids to facilitate 
   precise and accurate layout creation. It supports design rule checking (DRC) and layout versus schematic (LVS) verification, helping to identify and resolve 
   potential design errors and mismatches.

   Its feature-rich nature, extensibility, and community support make it an invaluable asset in the realm of digital integrated circuit design.

   > *You can refer to Magic manual [here](http://opencircuitdesign.com/magic/magic_docs.html)*

</section>


# Chip Planning Terminology
Physical design process starts with the *Chip Planning*. Physical Design implementation is strongly depends on the size of design and for large system we decompose them into the sub-systems or blocks which is also known as *partitioning*.

After partitioning we determine the location of each block and macros. we carry out pin assignment, define the location of input and output pads, allocatin adequate space for creating rows of standard cells which is known as floorplaning

Power planning is also done during the chip planning phase.

**DIE-SIZE** - For layout to be created we need to first define the die size and its aspect ratio. Ideally die size should be as small as possible which will allow us to fabricate more chips for a given wafer area, also reducing area reduces the cost of the chip also enables us to achieve a higher yield for smaller die.

Die-Size should be able to accomodate the following entities:

**1. Blocks** - A separate space need to be allocated on the layout for larger instances or blocks or macros. These blocks can obtained after partitioning or it can be functional blocks like processors, memories or analog blocks.

**2. Standard Cell** - Standard cell are placed on a die therefore a dedicated space is allocated for them. Area required for the standard cells can be estimated using the given netlist and the corresponding technology library.

**3. Pads** - I/O pads are required for the signals to enter or leave from a chip. Also power must be delivered to the chip using power and ground pads.

**4. Interconnects** - There must be provision of interconnects in the layout but during floorplan stage, the layout of the interconnect is not yet decided so it is challenging to estimate the area we must allocate for the interconnects on the die.

**5. Core Utilization or Core Area** - It is the die area excluding the area of the I/O pads and the power pads this is know as *core utilization*.

**6. Package** - It is a protective case that surrounds the circuit material to protect it from physical damage or corrosion and allow mounting of electrical contacts connecting it ti the PCB. Below shown snippet shows IC with 48 pins and Quad Flat No-Leads(QFN) package.


![image](https://github.com/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow/assets/57873021/95842423-0621-478f-b4e4-85212be5c3e3)


# Getting Started With the Flow

## **1. Running design synthesis using OpenLane flow and generate required output**

***Design Used - picorv32a***

PicoRV32 is a CPU core that implements the RISC-V RV32IMC Instruction Set. It can be configured as RV32I, RV32IC, RV32IM, or RV32IMC core
PicoRV32 is free and open hardware licensed under the ISC license. All features and data-sheet related to picoRV32 core can be obtained [here.](https://www.efabless.com/design_catalog/ip_block/92)

Adding our new design 

```
make mount
./flow.tcl -design picorv32a -init_design_config -add_to_designs -config_file config.tcl
it will create the respective directory and files

picorv32a
├── config.tcl
└── src
1 directory, 1 file
```

```bash
# Change directory to openlane flow directory
cd Desktop/work/tools/openlane_working_dir/openlane

# alias docker='docker run -it -v $(pwd):/openLANE_flow -v $PDK_ROOT:$PDK_ROOT -e PDK_ROOT=$PDK_ROOT -u $(id -u $USER):$(id -g $USER) efabless/openlane:v0.21'
# Since we have aliased the long command to 'docker' we can invoke the OpenLANE flow docker sub-system by just running this command
docker
```

```tcl
# Now that we have entered the OpenLANE flow contained docker sub-system we can invoke the OpenLANE flow in the Interactive mode using the following command
./flow.tcl -interactive 

# Now that OpenLANE flow is open we have to input the required packages for proper functionality of the OpenLANE flow which retrives all dependencies for running v0.9
package require openlane 0.9

# Now the OpenLANE flow is ready to run any design and initially we have to prep the design creating some necessary files and directories for running a specific design which in our case is 'picorv32a'
prep -design picorv32a

# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis

# Exit from OpenLANE flow
exit

# Exit from OpenLANE flow docker sub-system
exit
```

![Screenshot (360)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/3a7c600a-56bf-4f2f-befa-15a41551d9b9)

![Screenshot (361)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/e35a58e3-c35c-4b21-a3d6-a999092a20db)

**2. Calculating Flop Ratio**

```math
Flop\ Ratio = \frac{Number\ of\ D\ Flip\ Flops}{Total\ Number\ of\ Cells}
```

```math
Percentage\ of\ DFF's = Flop\ Ratio * 100
```

![Screenshot (363)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/4c2b742b-e003-493d-a999-de56758b5aa5)

![Screenshot (362)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/21a4219b-fec5-4fda-8014-7788ba2d420a)

```math
Flop\ Ratio = \frac{1613}{14876} = 0.1084
```

```math
Percentage\ of\ DFF's = 0.1084 * 100 = 10.84%
```

## **2. Florplan and Placement Stage**

**FLOORPLAN STAGE**

There are three styles of floorplan: *fully abutted*, *channel-based*, and *mixed* floorplan

**1. Fully Abutted floorplan** - It has no extra routing resources at the top level so entire top level wiring is done over the macros. We connect the blocks using abutment and pin alignment.

**2. Channel-based floorplan** - In this we ensure to keep gaps between blocks to allow top-level routing, these gaps are reffered to as channels. There is a chance of congestion issues in the channel since all top-level routing goes through it. Some routes through the channel can be longer than a direct path through another block.

**3. Mixed Floorplan** - It is a combination of both abutted and channel-based floorplan style. We abut blocks and create connections by pin alignment wherever possible, also create channels where top-level cells are needed between blocks or cells like clock routing buffers.

**Standard Cell Rows** - after placing object or macros in layout we can allocate the remaining area for standard cell rows, keeping the height of the rows equal to standard cell's height. Standard cell rows are created using abutment which allows adjacent rows to share the supply power rails (Vdd) and ground rails (GND).

**Pin Assignment** - Block location is fixed during the floorplan following by the fixing of position of pins of the blocks along the block boundaries this is known as *pin assignment*. Information required for pin placement is the partitioned netlist, the floorplan, the number of pins on each block and their relative ordering.

**Power Planning** - Chip draws external power through power pads delivering power to each active element of circuit. We make power ring across the periphery of a die and connect appropriate apdn to the power rings. Metal lines run horizontally and vertically in alternate metal layer and vias are added at their intersections this topology is called *mesh grid opology*. In this the horizontal metal lines are called *power rails* and vertical metal lines as *power straps*.

![2stage](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/c2e97cb9-0eb2-4191-a050-e9efd4062c4f)

**PLACEMENT STAGE**

One of the critical task to determine the locations of each entity in a design. We determine the position of larger entities such as memories, analog blocks, macros and input/output (I/O) pads during the floorplan stage. However location of numerous standard cell in decided in placement stage, primary aim for this stage is to make design routable. Placement methodology targets improving the slack of the timimg paths known as timing-driven placement.
Placement task is divided into multiple tasks like *global placement*, *legalization* followed by the *detailed palcement*

We try to find approximate cell locations by spreading the cells over the layout reducing the cell density cell location is decided by their connectivity and we ignore the attributes of the cell such as its size and pin location this is known as *global placement*. After this cell can overlap and occupy illegal positions which are fixed during the legalization and detailed placement stage.

```
configuration/
├── checkers.tcl
├── cts.tcl
├── extraction.tcl
├── floorplan.tcl
├── general.tcl
├── load_order.txt
├── placement.tcl
├── routing.tcl
└── synthesis.tcl

0 directories, 9 files
```

```
# Now that we have entered the OpenLANE flow contained docker sub-system we can invoke the OpenLANE flow in the Interactive mode using the following command
./flow.tcl -interactive

# Now that OpenLANE flow is open we have to input the required packages for proper functionality of the OpenLANE flow
package require openlane 0.9

# Now the OpenLANE flow is ready to run any design and initially we have to prep the design creating some necessary files and directories for running a specific design which in our case is 'picorv32a'
prep -design picorv32a

# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis

# Now we can run floorplan
run_floorplan
```

![floorplan run](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/d191a6c6-a4d3-4a40-88df-68201a23a1f5)


![floorplan run](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/b16fb76e-6095-477d-b196-ba10181e4072)


![floorplan run](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/d8062761-60c0-40d5-af50-2a22e7dff6ff)


![floorplan log](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/409961df-15b4-4672-839b-391bfe61f806)

after succesgul flooprplan run there will be a log generated from which can extract following content

```math
1000\ Unit\ Distance = 1\ Micron
```

```math
Die\ width\ in\ unit\ distance = 6600685 - 0 = 660685
```

```math
Die\ height\ in\ unit\ distance = 671405 - 0 = 671405
```

```math
Distance\ in\ microns = \frac{value\ in\ Unit\ Distance}{1000}
```

```math
Die\ width\ in\ microns = \frac{660685}{1000} = 660.685\ microns
```

```math
Die\ height\ in\ microns = \frac{671405}{1000} = 671.405\ microns
```

```math
Area\ of\ Die = Die\ height\ * Die\ widht
```

```math
Area\ of\ Die = 660.685 * 671.405 = 443587.212425\ square\ microns
```
```bash
# To invoke magic tool to view generated def file make sure in respective def generated dirctory
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.floorplan.def &
```

![floorplan def zoomed](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/685dbb65-afe2-4017-b897-94eecd9d11e5)

![floorplan def](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/058e242f-7196-46ba-a7b6-c4d73327d640)

after succesfully running floorplan stage now we will run the placement stage

```bash
# To run placement stage
run_placement
```

```bash
# Loading def file again after placement run make sure you are in respective def generated directory
magic -T /home/vsduser/Desktop/work/tools/openlane_working_dir/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.lef def read picorv32a.placement.def &
```

![placement def normal](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/6078adf0-edf7-4c84-bb40-139a296ceb72)

![placement def zoomed](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/fef07c24-7ca1-46d4-9d1f-080611fc40f3)

From the above results we can generated a floorplan with eqiudistant placement of ports, equidistant placement of Decap and Tap cells. And after placement standard cells are legally placed succesfully.


day -3 Characterization of standard cell inverter

oen of the feature of openlane is we can make changes on the fly for the specific stage and rerrun that \stage agin to get the changes visible itselff.
io place is opensource tool used to place the ios round the die.

VTC - spice simulation
what is spice netlist?
* component connectivity
* component values
* identify nodes
  * naming of nodes
 
![spice .cir](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/bd6c09f4-c1e4-4df9-a9b4-f2cf5e53b4fd)

 
```spice
***MODEL Description***
***NETLIST Description***
M1 out in vdd vdd pmos W=0.375u L=0.25u
M2 out in 0 0 nmos W=0.375u L=0.25u

cload out 0 10f

vdd vdd 0 2.5
vin in 0 2.5
***SIMULATION Commands***
.op
.dc vin 0 2.5 0.05
*** .include  model file***
.LIB lif file
.end
```

```
source *spice file* .cir
run
setplot - will show different plots available
display - will show different voltaages and current to plot
plot values
```

SPICE waveform : Wn=Wp=0.375u, Ln=Lp=0.25u
(Wn/Ln=Wp/Lp=1.5)


SPICE waveform : Wn=0.375u, Wp=0.9375u, Ln=Lp=0.25u
(Wn/Ln=1.5, Wp/Lp=3.75)

speciality of cmos
cmos is a robust device
switching threshold (static behaviour)


```spice
***MODEL Description***
***NETLIST Description***
M1 out in vdd vdd pmos W=0.375u L=0.25u
M2 out in 0 0 nmos W=0.375u L=0.25u

cload out 0 10f

vdd vdd 0 2.5
vin in 0 0 pulse 0 2.5 0 10p 10p 1n 2n
***SIMULATION Commands***
.op
.tran 10p 4n
*** .include  model file***
.LIB lif file
.end
```

![pulse waveform](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/6563146e-e468-42b0-a171-7ea7f14999a0)


Wp/Lp          x.Wn/Ln
"               1."
"               2."
"               3."
"               4."
"               5."



rise delay     fall delay
values            value

sky130 stack diagram
about magic tool
standard cell inverter layout

extraction
pwd
extract all
ext2spice ctrhesh 0 rthresh 0 // to extract parasitics
ext2spice

netlist file

rise time fall time definition

wget http://opencircuitdesign.com/open_pdks/archive/drc_tests.tgz
tar xzf "

implant layer are automatically generated in layout view they are not visible t view them  is to use cifc command to highlight those area

.magicrc startup file for magic
magic -d XR


met3.mag
drc why
paint m3con
cif see VIA2 
feed clear

1st exercise
load poly.mag
go to tech file in drc section
find the specific rule in tech file
*infront of layers means that specific layer and all the contacts containing rtthat layer
aliiases
tech load *file*
drc check

# Glossary

**Library Exchange Format (LEF)** : It is given by the foundry which contains the abstract information about the designIt includes unit definition, maufacturing grid, implant layer, Via, macro, macro pin statement etc. It has various flavours like standard cell lef contains physical information about various cells, Tech lef contains physical information about metal layers like spacing, pitch etc.

**Design Exchange Format (DEF)** : This file consist of information regarding placement of macros, I/O pins, standard cells and other physical entities. Initial DEF to the flow is given by the synthesis stage. It get updated at every stage of the physical design flow. Physical deign data contains routing geometry, placement location and orientation. It is an input to various stages in physical design.
In short it conatains dies are, tracks, components(macros), I/O pins, nets, Halo, vias, metal layers.

**Liberty Timimg File (LIB)** : It is a timimg model ontaining the cell delays, setup and hold time requirements. Composite current source (CCS) and non linear delay model (NLDM) are used to generate .lib files.
Designs are needed to be tested for certain PVT corners and for every PVT corner timing of a cell is different and hence .lib file is for every PVT corner.
