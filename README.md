# Physical_Design_Using_OpenLane_Flow
This repository contains a detailed description of a RTL2GDSII flow using a opensource OpenLane flow, design used for this run is PicoRV32 which is a CPU core that implements the RISC-V Instruction Set.

![Static Badge](https://img.shields.io/badge/OS-linux-orange)
![Static Badge](https://img.shields.io/badge/EDA%20Tools-OpenLANE--Flow%2C_Yosys%2C_abc%2C_OpenROAD%2C_TritonRoute%2C_OpenSTA%2C_magic%2C_netgen%2C_GUNA-navy)
![Static Badge](https://img.shields.io/badge/languages-verilog%2C_bash%2C_TCL-crimson)
![GitHub last commit](https://img.shields.io/github/last-commit/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub language count](https://img.shields.io/github/languages/count/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub top language](https://img.shields.io/github/languages/top/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub repo size](https://img.shields.io/github/repo-size/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub code size in bytes](https://img.shields.io/github/languages/code-size/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)
![GitHub repo file count (file type)](https://img.shields.io/github/directory-file-count/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow)

# Physical Design
It is a process of generating a layout from a given netlist, in which layout is represented in GDS or geometrical patterns which are written on mask for IC fabrication.

Following are inputs during this step and the final output is GDS:

**1. Netlist** - Netlist generated by the logic synthesis tool as an input to the physical design tool.

**2. Library** - A library which contains the cells instantiated in the above netlist is provided which helps in computing delay and other attributes for cell instances using this library.

**3. Constraints** - Design goals and constraints are provided to physical design tool through various design configuration variables which help to acheive the required result.

**4. Floorplan** - A floorplan captures the designer's intent about physical design. It defines the size and aspect ratio of a die. It contains location of hard macros, shape, location of various blocks, location of input/output (I/O) pads. It act as a constraint in placing various component and creating a wire layout.

**Major Tasks**

* Chip Planning
* Placement
* Clock Tree Synthesis
* Global Routing
* Detailed Routing
* ECO (Engineering Change Order)
* Write GDS

# OpenLane
It is an automated RTL2GDSII flow which make use of several other opensource tools throughout the run to generate the GDSII like, OpenROAD, Yosys, Magic, Netgen, CVC, SPEF-Extractor, KLayout and other custom script for optimized flow.

Physical design tool determines the location of all instances in a design which decides the clocking structure. It builds the topology of the metal and via layer for all nets in a design. Finally a layout represented in GDS format which contains all the information required for the fabricating a chip.


# OpenLane Architecture
![image](https://github.com/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow/assets/57873021/10499621-3e2f-4f80-b5a6-ffa6fa333f64)


RTL2GDSII flow consist of various steps involved which help in converting Register Transfer Level(RTL) to a fabrication ready GDSII(Graphic Design System) format it is a industry standard for data exchange of IC layout.

* RTL Synthesis
* Static Timing Analysis(STA)
* Design for Testability(DFT)
* Floorplanning
* Placement
* Clock Tree Synthesis(CTS)
* Routing
* GDSII Streaming

This repository shows the detailed execution of all the above mentioned steps to complete the flow.

### OpenLane Directory Hierarchy:

``` 
├── OpenLane              -> directory where the tool can be invoked (make mount first)
│   ├── designs           -> All designs are present in this folder
│   │   │   ├── picorv32a -> Design used as case study for this flow this contains all the required files to succesfully run the flow like (.v, .sdc, congif files etc)
│   |   |   ├── ...
|   |   ├── ...
├── pdks                 -> contains pdk related files 
│   ├── skywater-pdk     -> all Skywater 130nm PDKs
│   ├── open-pdks        -> contains scripts that makes the commerical PDK (which is normally just compatible to commercial tools) to also be compatible with the open-source EDA tool
│   ├── sky130A          -> pdk variant made especially compatible for open-source tools
│   │   │  ├── libs.ref  -> files specific to node process (timing lib, cell lef, tech lef) for example is `sky130_fd_sc_hd` (Sky130nm Foundry Standard Cell High Density)  
│   │   │  ├── libs.tech -> files specific related to the tool (klayout,netgen,magic...) 
```

**Skywater Technology**
   
   ![image](https://github.com/SudeepGopavaram/Design_and_analysis_of_nmos_and_pmos_using_sky130pdk/assets/57873021/f8f19c5c-1ded-40c1-a87b-82dc2e572bab)

The [SkyWater](https://www.skywatertechnology.com/technology-and-design-enablement/) Technology Foundry 130nm Process Design Kit (PDK) is a comprehensive collection of files, libraries, and documentation that enables the design and fabrication of integrated circuits (ICs) using the SkyWater 130nm process technology.

   The SkyWater130 PDK is typically utilized in conjunction with electronic design automation (EDA) tools, enabling designers to create and verify their IC designs 
   within a familiar design environment. The PDK provides the necessary information for layout design, including design rules, layer information, and guidelines for 
   ensuring compatibility with the SkyWater 130nm process technology.

   Overall, the SkyWater130 PDK is an essential resource for IC designers seeking to leverage the capabilities of the SkyWater 130nm process technology. Its 
   comprehensive set of files, libraries, and guidelines streamline the design process and facilitate the creation of high-quality integrated circuits.

   > *You can refer to skywater130 manual [here](https://skywater-pdk.readthedocs.io/en/main/)*

 **Yosys -- Yosys Open SYnthesis Suite**
![image](https://github.com/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow/assets/57873021/61878d69-c9fe-4f25-86e1-989ac45dea4d)

This tool is used to perform any synthesis job it is a framework for verilog RTL synthesis and provides a basic set of synthesis algorithms for various application domains


# Chip Planning Terminology
Physical design process starts with the *Chip Planning*. Physical Design implementation is strongly depends on the size of design and for large system we decompose them into the sub-systems or blocks which is also known as *partitioning*.

After partitioning we determine the location of each block and macros. we carry out pin assignment, define the location of input and output pads, allocatin adequate space for creating rows of standard cells which is known as floorplaning

Power planning is also done during the chip planning phase.

**DIE-SIZE** - For layout to be created we need to first define the die size and its aspect ratio. Ideally die size should be as small as possible which will allow us to fabricate more chips for a given wafer area, also reducing area reduces the cost of the chip also enables us to achieve a higher yield for smaller die.

Die-Size should be able to accomodate the following entities:

**1. Blocks** - A separate space need to be allocated on the layout for larger instances or blocks or macros. These blocks can obtained after partitioning or it can be functional blocks like processors, memories or analog blocks.

**2. Standard Cell** - Standard cell are placed on a die therefore a dedicated space is allocated for them. Area required for the standard cells can be estimated using the given netlist and the corresponding technology library.

**3. Pads** - I/O pads are required for the signals to enter or leave from a chip. Also power must be delivered to the chip using power and ground pads.

**4. Interconnects** - There must be provision of interconnects in the layout but during floorplan stage, the layout of the interconnect is not yet decided so it is challenging to estimate the area we must allocate for the interconnects on the die.

**5. Core Utilization or Core Area** - It is the die area excluding the area of the I/O pads and the power pads this is know as *core utilization*.

**6. Package** - It is a protective case that surrounds the circuit material to protect it from physical damage or corrosion and allow mounting of electrical contacts connecting it ti the PCB. Below shown snippet shows IC with 48 pins and Quad Flat No-Leads(QFN) package.


![image](https://github.com/SudeepGopavaram/Physical_Design_Using_OpenLane_Flow/assets/57873021/95842423-0621-478f-b4e4-85212be5c3e3)


# Getting Started With the Flow

**1. Running design synthesis using OpenLane flow and generate required output**
*Design Used - picorv32a*

Adding our new design 

```
make mount
./flow.tcl -design picorv32a -init_design_config -add_to_designs -config_file config.tcl
it will create the respective directory and files

picorv32a
├── config.tcl
└── src
1 directory, 1 file
```

```bash
# Change directory to openlane flow directory
cd Desktop/work/tools/openlane_working_dir/openlane

# alias docker='docker run -it -v $(pwd):/openLANE_flow -v $PDK_ROOT:$PDK_ROOT -e PDK_ROOT=$PDK_ROOT -u $(id -u $USER):$(id -g $USER) efabless/openlane:v0.21'
# Since we have aliased the long command to 'docker' we can invoke the OpenLANE flow docker sub-system by just running this command
docker
```

```tcl
# Now that we have entered the OpenLANE flow contained docker sub-system we can invoke the OpenLANE flow in the Interactive mode using the following command
./flow.tcl -interactive 

# Now that OpenLANE flow is open we have to input the required packages for proper functionality of the OpenLANE flow which retrives all dependencies for running v0.9
package require openlane 0.9

# Now the OpenLANE flow is ready to run any design and initially we have to prep the design creating some necessary files and directories for running a specific design which in our case is 'picorv32a'
prep -design picorv32a

# Now that the design is prepped and ready, we can run synthesis using following command
run_synthesis

# Exit from OpenLANE flow
exit

# Exit from OpenLANE flow docker sub-system
exit
```

![Screenshot (360)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/3a7c600a-56bf-4f2f-befa-15a41551d9b9)

![Screenshot (361)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/e35a58e3-c35c-4b21-a3d6-a999092a20db)



**2. Calculating Flop Ratio**

```math
Flop\ Ratio = \frac{Number\ of\ D\ Flip\ Flops}{Total\ Number\ of\ Cells}
```

```math
Percentage\ of\ DFF's = Flop\ Ratio * 100
```

![Screenshot (363)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/4c2b742b-e003-493d-a999-de56758b5aa5)

![Screenshot (362)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/21a4219b-fec5-4fda-8014-7788ba2d420a)


```math
Flop\ Ratio = \frac{1613}{14876} = 0.1084
```

```math
Percentage\ of\ DFF's = 0.1084 * 100 = 10.84%
```

**2. Florplan and Placement Stage**


# Glossary
* Tech file 


![Screenshot (364)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/d191a6c6-a4d3-4a40-88df-68201a23a1f5)


![Screenshot (365)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/b16fb76e-6095-477d-b196-ba10181e4072)




![Screenshot (366)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/d8062761-60c0-40d5-af50-2a22e7dff6ff)

![Screenshot (370)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/685dbb65-afe2-4017-b897-94eecd9d11e5)

![Screenshot (371)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/409961df-15b4-4672-839b-391bfe61f806)



![Screenshot (369)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/058e242f-7196-46ba-a7b6-c4d73327d640)



![Screenshot (367)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/6078adf0-edf7-4c84-bb40-139a296ceb72)

![Screenshot (368)](https://github.com/SudeepGopavaram/SoC_Design_and_Chip_Planning_Using_OpenLane_Flow/assets/57873021/fef07c24-7ca1-46d4-9d1f-080611fc40f3)





